# 강의 정리 🚀
___

> 2021.09.29 SpringBoot Part

## 공부한 내용

- ### 모든 것은 공식문서와 함께!!! ###


- ### 연관관계 매핑 ###
    - 테이블은 외래키로 연관관계를 맺는다.(FK)
    - 객체는 참조(주소)로 연관관계를 맺는다.
    - @ManyToOne / @OneToMany

    - 핵심 키워드
        - 방향(단방향, 양방향)
            - 회원 -> 주문 또는 주문 -> 회원 둘 중 한쪽만 참조하는 것을 단방향 관계라고 한다.(회원이 주문을 참조할 수 있다.)
            - 회원 -> 주문 , 주문 -> 회원 양쪽 모두 서로 참조하는 것을 양방향 관계라고 한다.(A,B가 있을 때 둘다 각각 서로를 get() 할수 있는 경우이다.)
            - 테이블에서의 관계는 항상 양방향이다.
        - 다중성(다대일, 일대다, 다대다)
            - 회원은 여러 주문을 할 수 있기 대문에 회원(1)과 주문(N)은 일대다 관계이다.
            - 주문은 여러 회원에 의해 발생할 수 있기 때문에, 주문(N)과 회원(1)은 다대일 관계이다.
        - 연관관계 주인(mappedBy)
            - 객체를 양방향 연관관계로 만들면, 연관관계의 주인을 정해야 한다.
            - 외래키를 관리할 객체를 지정한다.(INSERT,UPDATE)
            - 연관관계의 주인만이, 외래키를 등록 수정 삭제할 수 있다.(주인이 아닌 쪽은 읽기만 가능하다.)
            - 테이블 중, FK가 있는 쪽이 연관관계 주인이 된다. (회원(1) 과 주문(N)에서는 주문(N)이 연관관계의 주인이 된다.)

- ### 고급 매핑 ###
    - 상속을 하기 위해서는 @Inheritance를 사용할 수 있다.
    - 상속 전략으로는 JOIN / SINGLE TABLE 이 있다. 
        - SINGLE TABLE 전략은 @DiscriminatorValue / DiscriminatorColumn을 이용해서 작성한다. 이는, 자식 수만큼 테이블이 생기던 JOIN 전략과는 다르게 하나의 테이블이 생성되어 구분자로 구분한다.
    - 실무에서는 JOIN은 테이블이 워낙 많아지고, 관리할게 많아지므로 SINGLE TABLE 전략을 좀더 많이 사용한다. 하지만, 둘다 알아야한다!

    - 식별자 클래스
        - 조건
            1. Serializable 인터페이스를 구현해야한다.
            2. equals, hashCode를 구현해야 한다.
            3. 기본 생성자가 있어야 한다.
            4. 식별자 클래스는 public 이어야 한다.
        - 하지만, 객체지향스럽지는 않다.

    - EmbeddedId
        - 실무에서는 이것을 주로 사용한다.
        - 식별자 클래스보다 좀 더 객체지향 스러운 면이 있어서 자주 사용된다. 
            - 객체를 선언하면서 id를 선언할 수 있다.


- ### 프록시 ###
    - 아래 개념과 설명은 모두 예시와 함께 봐야한다. 단순히 글로 봐서는 이해가 힘들 듯!
    (강의 코드와 함께 보기)
    - 객체는 객체 그래프로 연관된 객체를 탐색한다.
    - Entity는 객체가 RDB와 매핑되어 있어서 자유롭게 객체를 탐색하는데 제한이 있다.
    - JPA는 프록시라는 기술을 사용하여 연관된 객체를 처음부터 DB에서 조회하지 않고, 실제 사용하는 시점에 조회할 수 있다.
        - fetch가 LAZY로 설정을 하면 proxy 객체가 되고, 사용을 할 시점에 조회가 된다.
    - 프록시의 특징
        - 프록시 객체는 처음 사용할 때 한번만 초기화 된다.
        - 프록시 객체가 초기화 되면, 프록시 객체를 통해서 실제 엔티티에 접근할 수 있다.
        - 초기화는 영속성 컨텍스트의 도움을 받아야 가능하다. 따라서 준영속 상태의 프록시를 초기화 하면 LazyInitializationException 예외가 발생한다.
            - 이 예외는 프록시 객체인데, 프록시 객체를 사용하려고 할때 주로 발생한다.

    - 지연로딩 / 즉시 로딩
        - Fetch 전략이 Lazy / Eager에 의해 나눠진다. Lazy일 경우, 해당하는 객체를 사용할 때 DB에 접근해서 가져오는 것이며 Eager는 처음부터 객체를 가져오는 것이다.
        - getPersistenceUnitUtil().isLoaded(객체) 메소드를 통해 객체가 현재 프록시 객체인지 아닌지를 판단할 수 있다.
    - 영속성 전이
        - Cascase 옵션을 통해서 지정할 수 잇다. cascade 옵션을 주지 않을 경우, 영속상태가 아닌 것은 적절한 쿼리가 날라가지 않는다. 
    - 고아 객체
        - orphanRemoval 옵션을 통해 값을 지정할 수 있으며 default는 false이다. 그러므로, 쿼리가 날라가지 않아 고아객체가 생길 수 있는데 이럴 때 true로 할 경우, 쿼리가 날라가서 RDS에서도 삭제가 된다.


